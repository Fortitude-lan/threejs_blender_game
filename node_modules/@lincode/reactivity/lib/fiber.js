import { Cancellable } from "@lincode/promiselikes";
import { debounce } from "@lincode/utils";
const fiberStack = [];
const fiberCache = (value) => {
    var _a;
    var _b, _c;
    const store = fiberStack[fiberStack.length - 1];
    return (_a = (_b = store.fiber)[_c = store.count++]) !== null && _a !== void 0 ? _a : (_b[_c] = value());
};
const fiberStore = (value) => {
    var _a;
    var _b;
    const store = fiberStack[fiberStack.length - 1];
    const index = store.count++;
    (_a = (_b = store.fiber)[index]) !== null && _a !== void 0 ? _a : (_b[index] = value);
    return [
        () => store.fiber[index],
        (val) => store.fiber[index] = val
    ];
};
const diffAndRun = (cleanup, fiber, getStates, statesOld, cb) => {
    fiberStack.push({ count: 0, fiber });
    const states = getStates.map(s => typeof s === "function" ? s() : s);
    const shouldRun = !statesOld || states.some((s, i) => s !== statesOld[i]);
    shouldRun && (cleanup === null || cleanup === void 0 ? void 0 : cleanup());
    const result = shouldRun ? cb() : undefined;
    fiberStack.pop();
    return [result, states, shouldRun];
};
export const createEffect = (cb, getStates) => {
    if (fiberStack.length) {
        const handle = fiberCache(() => new Cancellable(() => cleanup === null || cleanup === void 0 ? void 0 : cleanup()));
        if (handle.done)
            return handle;
        const fiber = fiberCache(() => []);
        const [getCleanUp, setCleanUp] = fiberStore(undefined);
        const [getStatesOld, setStatesOld] = fiberStore(undefined);
        const cleanup = getCleanUp();
        const statesOld = getStatesOld();
        const [result, states, shouldRun] = diffAndRun(cleanup, fiber, getStates, statesOld, cb);
        shouldRun && setCleanUp(typeof result === "function" ? result : undefined);
        setStatesOld(states);
        return handle;
    }
    else {
        const handle = new Cancellable(() => cleanup === null || cleanup === void 0 ? void 0 : cleanup());
        const fiber = [];
        let cleanup;
        let statesOld;
        const cbDebounced = debounce(() => {
            const [result, states, shouldRun] = diffAndRun(cleanup, fiber, getStates, statesOld, cb);
            shouldRun && (cleanup = typeof result === "function" ? result : undefined);
            statesOld = states;
        }, 0, "trailing");
        cbDebounced();
        for (const getState of getStates)
            typeof getState === "function" && handle.watch(getState(cbDebounced));
        return handle;
    }
};
export const createRef = (value) => {
    var _a;
    var _b, _c;
    const store = fiberStack[fiberStack.length - 1];
    //@ts-ignore
    return (_a = (_b = store.fiber)[_c = store.count++]) !== null && _a !== void 0 ? _a : (_b[_c] = { current: typeof value === "function" ? value() : value });
};
export const createPrevious = (value) => {
    const valueRef = createRef(value);
    createEffect(() => {
        queueMicrotask(() => valueRef.current = value);
    }, [value]);
    return valueRef.current;
};
export const createMemo = (value, getStates) => {
    const valueRef = createRef(value);
    createEffect(() => {
        valueRef.current = value();
    }, getStates);
    return valueRef.current;
};
