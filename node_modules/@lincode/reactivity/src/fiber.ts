import { Cancellable } from "@lincode/promiselikes"
import { debounce } from "@lincode/utils"
import { GetGlobalState } from "./store"

const fiberStack: Array<{ count: number, fiber: Array<any> }> = []

const fiberCache = <T>(value: () => T): T => {
    const store = fiberStack[fiberStack.length - 1]
    return store.fiber[store.count++] ??= value()
}

const fiberStore = <T>(value: T): [() => T, (val: T) => void] => {
    const store = fiberStack[fiberStack.length - 1]
    const index = store.count++
    store.fiber[index] ??= value
    return [
        () => store.fiber[index],
        (val: T) => store.fiber[index] = val
    ]
}

const diffAndRun = (
    cleanup: (() => void) | undefined,
    fiber: Array<any>,
    getStates: Array<GetGlobalState<any> | any>,
    statesOld: Array<any> | undefined,
    cb: () => (() => void) | Promise<void> | void
) => {
    fiberStack.push({ count: 0, fiber })
    const states = getStates.map(s => typeof s === "function" ? s() : s)
    const shouldRun = !statesOld || states.some((s, i) => s !== statesOld![i])
    shouldRun && cleanup?.()
    const result = shouldRun ? cb() : undefined
    fiberStack.pop()

    return <const>[result, states, shouldRun]
}

export const createEffect = (
    cb: () => (() => void) | Promise<void> | void,
    getStates: Array<GetGlobalState<any> | any>
) => {
    if (fiberStack.length) {
        const handle = fiberCache(() => new Cancellable(() => cleanup?.()))
        if (handle.done) return handle

        const fiber: Array<any> = fiberCache(() => [])

        const [getCleanUp, setCleanUp] = fiberStore<(() => void) | undefined>(undefined)
        const [getStatesOld, setStatesOld] = fiberStore<Array<any> | undefined>(undefined)

        const cleanup = getCleanUp()
        const statesOld = getStatesOld()

        const [result, states, shouldRun] = diffAndRun(cleanup, fiber, getStates, statesOld, cb,)

        shouldRun && setCleanUp(typeof result === "function" ? result : undefined)
        setStatesOld(states)

        return handle
    }
    else {
        const handle = new Cancellable(() => cleanup?.())
        const fiber: Array<any> = []
        
        let cleanup: (() => void) | undefined
        let statesOld: Array<any> | undefined

        const cbDebounced = debounce(() => {
            const [result, states, shouldRun] = diffAndRun(cleanup, fiber, getStates, statesOld, cb)
    
            shouldRun && (cleanup = typeof result === "function" ? result : undefined)
            statesOld = states

        }, 0, "trailing")
        
        cbDebounced()
        for (const getState of getStates)
            typeof getState === "function" && handle.watch(getState(cbDebounced))

        return handle
    }
}

export const createRef = <T>(value?: T | (() => T)): { current: T } => {
    const store = fiberStack[fiberStack.length - 1]
    //@ts-ignore
    return store.fiber[store.count++] ??= { current: typeof value === "function" ? value() : value }
}

export const createPrevious = <T>(value: T) => {
    const valueRef = createRef(value)

    createEffect(() => {
        queueMicrotask(() => valueRef.current = value)
    }, [value])

    return valueRef.current
}

export const createMemo = <T>(
    value: () => T,
    getStates: Array<GetGlobalState<any> | any>
) => {
    const valueRef = createRef(value)

    createEffect(() => {
        valueRef.current = value()
    }, getStates)

    return valueRef.current
}