{
  "version": 3,
  "sources": ["../three/examples/jsm/objects/ReflectorForSSRPass.js"],
  "sourcesContent": ["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget,\n\tDepthTexture,\n\tUnsignedShortType,\n\tNearestFilter,\n\tPlane\n} from 'three';\n\nclass ReflectorForSSRPass extends Mesh {\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.type = 'ReflectorForSSRPass';\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n\t\tconst useDepthTexture = options.useDepthTexture === true;\n\t\tconst yAxis = new Vector3( 0, 1, 0 );\n\t\tconst vecTemp0 = new Vector3();\n\t\tconst vecTemp1 = new Vector3();\n\n\t\t//\n\n\t\tscope.needsUpdate = false;\n\t\tscope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n\t\tscope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n\t\tscope.color = color;\n\t\tscope.resolution = options.resolution || new Vector2( window.innerWidth, window.innerHeight );\n\n\n\t\tscope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n\t\tObject.defineProperty( scope, 'distanceAttenuation', {\n\t\t\tget() {\n\n\t\t\t\treturn scope._distanceAttenuation;\n\n\t\t\t},\n\t\t\tset( val ) {\n\n\t\t\t\tif ( scope._distanceAttenuation === val ) return;\n\t\t\t\tscope._distanceAttenuation = val;\n\t\t\t\tscope.material.defines.DISTANCE_ATTENUATION = val;\n\t\t\t\tscope.material.needsUpdate = true;\n\n\t\t\t}\n\t\t} );\n\n\t\tscope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n\t\tObject.defineProperty( scope, 'fresnel', {\n\t\t\tget() {\n\n\t\t\t\treturn scope._fresnel;\n\n\t\t\t},\n\t\t\tset( val ) {\n\n\t\t\t\tif ( scope._fresnel === val ) return;\n\t\t\t\tscope._fresnel = val;\n\t\t\t\tscope.material.defines.FRESNEL = val;\n\t\t\t\tscope.material.needsUpdate = true;\n\n\t\t\t}\n\t\t} );\n\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = new PerspectiveCamera();\n\n\t\tlet depthTexture;\n\n\t\tif ( useDepthTexture ) {\n\n\t\t\tdepthTexture = new DepthTexture();\n\t\t\tdepthTexture.type = UnsignedShortType;\n\t\t\tdepthTexture.minFilter = NearestFilter;\n\t\t\tdepthTexture.magFilter = NearestFilter;\n\n\t\t}\n\n\t\tconst parameters = {\n\t\t\tdepthTexture: useDepthTexture ? depthTexture : null,\n\t\t};\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\ttransparent: useDepthTexture,\n\t\t\tdefines: Object.assign( {}, ReflectorForSSRPass.ReflectorShader.defines, {\n\t\t\t\tuseDepthTexture\n\t\t\t} ),\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = scope.color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\t\tif ( useDepthTexture ) {\n\n\t\t\tmaterial.uniforms[ 'tDepth' ].value = renderTarget.depthTexture;\n\n\t\t}\n\n\t\tthis.material = material;\n\n\t\tconst globalPlane = new Plane( new Vector3( 0, 1, 0 ), clipBias );\n\t\tconst globalPlanes = [ globalPlane ];\n\n\t\tthis.doRender = function ( renderer, scene, camera ) {\n\n\t\t\tmaterial.uniforms[ 'maxDistance' ].value = scope.maxDistance;\n\t\t\tmaterial.uniforms[ 'color' ].value = scope.color;\n\t\t\tmaterial.uniforms[ 'opacity' ].value = scope.opacity;\n\n\t\t\tvecTemp0.copy( camera.position ).normalize();\n\t\t\tvecTemp1.copy( vecTemp0 ).reflect( yAxis );\n\t\t\tmaterial.uniforms[ 'fresnelCoe' ].value = ( vecTemp0.dot( vecTemp1 ) + 1. ) / 2.; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tmaterial.uniforms[ 'virtualCameraNear' ].value = camera.near;\n\t\t\tmaterial.uniforms[ 'virtualCameraFar' ].value = camera.far;\n\t\t\tmaterial.uniforms[ 'virtualCameraMatrixWorld' ].value = virtualCamera.matrixWorld;\n\t\t\tmaterial.uniforms[ 'virtualCameraProjectionMatrix' ].value = camera.projectionMatrix;\n\t\t\tmaterial.uniforms[ 'virtualCameraProjectionMatrixInverse' ].value = camera.projectionMatrixInverse;\n\t\t\tmaterial.uniforms[ 'resolution' ].value = scope.resolution;\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Render\n\n\t\t\trenderTarget.texture.encoding = renderer.outputEncoding;\n\n\t\t\t// scope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\t\t\tconst currentClippingPlanes = renderer.clippingPlanes;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\trenderer.clippingPlanes = globalPlanes;\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.clippingPlanes = currentClippingPlanes;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\t// scope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t}\n\n}\n\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\n\nReflectorForSSRPass.ReflectorShader = {\n\n\tdefines: {\n\t\tDISTANCE_ATTENUATION: true,\n\t\tFRESNEL: true,\n\t},\n\n\tuniforms: {\n\n\t\tcolor: { value: null },\n\t\ttDiffuse: { value: null },\n\t\ttDepth: { value: null },\n\t\ttextureMatrix: { value: new Matrix4() },\n\t\tmaxDistance: { value: 180 },\n\t\topacity: { value: 0.5 },\n\t\tfresnelCoe: { value: null },\n\t\tvirtualCameraNear: { value: null },\n\t\tvirtualCameraFar: { value: null },\n\t\tvirtualCameraProjectionMatrix: { value: new Matrix4() },\n\t\tvirtualCameraMatrixWorld: { value: new Matrix4() },\n\t\tvirtualCameraProjectionMatrixInverse: { value: new Matrix4() },\n\t\tresolution: { value: new Vector2() },\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`,\n};\n\nexport { ReflectorForSSRPass };\n"],
  "mappings": "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",
  "names": []
}
