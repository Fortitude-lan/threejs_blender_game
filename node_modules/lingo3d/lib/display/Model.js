import fit from "./utils/fit";
import Loaded from "./core/Loaded";
import { lazy } from "@lincode/utils";
import AnimationManager from "./core/SimpleObjectManager/AnimationManager";
import { scaleDown } from "../engine/constants";
import { objectURLMapperPtr } from "./utils/loaders/setObjectURLMapper";
const lazyLoadFBX = lazy(() => import("./utils/loaders/loadFBX"));
const lazyLoadGLTF = lazy(() => import("./utils/loaders/loadGLTF"));
export default class Model extends Loaded {
    loadAnimation(url, name = url) {
        var _a;
        ((_a = this.animationPromises) !== null && _a !== void 0 ? _a : (this.animationPromises = [])).push(new Promise(async (resolve) => {
            const data = await this.load(url);
            const loadedObject3d = await this.loadedResolvable;
            const clip = data.animations[0];
            clip && (this.animations[name] = this.watch(new AnimationManager(clip, loadedObject3d)));
            resolve();
        }));
    }
    get animations() {
        var _a;
        return (_a = this.animationManagers) !== null && _a !== void 0 ? _a : (this.animationManagers = {});
    }
    set animations(val) {
        for (const [key, value] of Object.entries(val))
            if (typeof value === "string")
                this.loadAnimation(value, key);
            else
                this.animations[key] = value;
    }
    load(url) {
        if (objectURLMapperPtr[0](url).endsWith(".fbx"))
            return lazyLoadFBX().then(loader => loader.default(url));
        return lazyLoadGLTF().then(loader => loader.default(url));
    }
    get loadedScale() {
        var _a;
        return (_a = this._loadedScale) !== null && _a !== void 0 ? _a : 1;
    }
    set loadedScale(val) {
        this._loadedScale = val;
    }
    get loadedX() {
        var _a;
        return (_a = this._loadedX) !== null && _a !== void 0 ? _a : 0;
    }
    set loadedX(val) {
        this._loadedX = val;
        this._loadedPos = true;
    }
    get loadedY() {
        var _a;
        return (_a = this._loadedY) !== null && _a !== void 0 ? _a : 0;
    }
    set loadedY(val) {
        this._loadedY = val;
        this._loadedPos = true;
    }
    get loadedZ() {
        var _a;
        return (_a = this._loadedZ) !== null && _a !== void 0 ? _a : 0;
    }
    set loadedZ(val) {
        this._loadedZ = val;
        this._loadedPos = true;
    }
    resolveLoaded(loadedObject3d) {
        for (const clip of loadedObject3d.animations)
            this.animations[clip.name] = this.watch(new AnimationManager(clip, loadedObject3d));
        if (this._loadedScale)
            loadedObject3d.scale.multiplyScalar(this.loadedScale);
        else {
            const size = fit(loadedObject3d, this._src);
            !this.widthSet && (this.object3d.scale.x = size.x);
            !this.heightSet && (this.object3d.scale.y = size.y);
            !this.depthSet && (this.object3d.scale.z = size.z);
        }
        if (this._loadedPos) {
            let { x, y, z } = loadedObject3d.position;
            this._loadedX && (x = this._loadedX * scaleDown);
            this._loadedY && (y = this._loadedY * scaleDown);
            this._loadedZ && (z = this._loadedZ * scaleDown);
            loadedObject3d.position.set(x, y, z);
        }
        this.loadedGroup.add(loadedObject3d);
        this.loadedResolvable.resolve(loadedObject3d);
    }
}
