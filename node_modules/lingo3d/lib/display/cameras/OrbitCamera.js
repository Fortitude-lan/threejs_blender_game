import { deg2Rad, rad2Deg } from "@lincode/math";
import { createEffect } from "@lincode/reactivity";
import { applyMixins } from "@lincode/utils";
import { PerspectiveCamera } from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { camFar, camNear, scaleDown, scaleUp } from "../../engine/constants";
import { container } from "../../engine/render/renderer";
import { getCamera } from "../../states/useCamera";
import { getCameraDistance } from "../../states/useCameraDistance";
import EventLoopItem from "../../api/core/EventLoopItem";
import CameraMixin from "../core/mixins/CameraMixin";
import { loop } from "../../engine/eventLoop";
class OrbitCamera extends EventLoopItem {
    constructor() {
        super();
        this.camera = new PerspectiveCamera(75, 1, camNear, camFar);
        this.outerObject3d = this.camera;
        this.controls = new OrbitControls(this.camera, container);
        this.initOuterObject3d();
        this.initCamera();
        this.camera.position.z = getCameraDistance();
        this.controls.update();
        this.watch(createEffect(() => {
            const enabled = this.controls.enabled = getCamera() === this.camera;
            if (!enabled)
                return;
            const handle = loop(() => this.controls.update());
            return () => {
                handle.cancel();
            };
        }, [getCamera]));
        this.controls.enablePan = false;
        this.controls.enableZoom = false;
        this.then(() => this.controls.dispose());
    }
    get targetX() {
        var _a;
        return (_a = this._targetX) !== null && _a !== void 0 ? _a : (this._targetX = 0);
    }
    set targetX(val) {
        this._targetX = val;
        this.controls.target.x = val * scaleDown;
    }
    get targetY() {
        var _a;
        return (_a = this._targetY) !== null && _a !== void 0 ? _a : (this._targetY = 0);
    }
    set targetY(val) {
        this._targetY = val;
        this.controls.target.y = val * scaleDown;
    }
    get targetZ() {
        var _a;
        return (_a = this._targetZ) !== null && _a !== void 0 ? _a : (this._targetZ = 0);
    }
    set targetZ(val) {
        this._targetZ = val;
        this.controls.target.z = val * scaleDown;
    }
    get x() {
        return this.camera.position.x * scaleUp;
    }
    set x(val) {
        this.camera.position.x = val * scaleDown;
    }
    get y() {
        return this.camera.position.y * scaleUp;
    }
    set y(val) {
        this.camera.position.y = val * scaleDown;
    }
    get z() {
        return this.camera.position.z * scaleUp;
    }
    set z(val) {
        this.camera.position.z = val * scaleDown;
    }
    get rotationX() {
        return this.camera.rotation.x * rad2Deg;
    }
    get rotationY() {
        return this.camera.rotation.y * rad2Deg;
    }
    get rotationZ() {
        return this.camera.rotation.z * rad2Deg;
    }
    get enableDamping() {
        return this.controls.enableDamping;
    }
    set enableDamping(val) {
        this.controls.enableDamping = val;
    }
    get enablePan() {
        return this.controls.enablePan;
    }
    set enablePan(val) {
        this.controls.enablePan = val;
    }
    get enableZoom() {
        return this.controls.enableZoom;
    }
    set enableZoom(val) {
        this.controls.enableZoom = val;
    }
    get autoRotate() {
        return this.controls.autoRotate;
    }
    set autoRotate(val) {
        this.controls.autoRotate = val;
    }
    get autoRotateSpeed() {
        return this.controls.autoRotateSpeed;
    }
    set autoRotateSpeed(val) {
        this.controls.autoRotateSpeed = val;
    }
    setRotationY(val, lock) {
        this.controls.minAzimuthAngle = this.controls.maxAzimuthAngle = val * deg2Rad;
        this.controls.update();
        if (lock)
            return;
        queueMicrotask(() => {
            this.controls.minAzimuthAngle = -Infinity;
            this.controls.maxAzimuthAngle = Infinity;
        });
    }
    setRotationX(val, lock) {
        this.controls.minPolarAngle = this.controls.maxPolarAngle = (val + 90) * deg2Rad;
        this.controls.update();
        if (lock)
            return;
        queueMicrotask(() => {
            this.controls.minPolarAngle = -Infinity;
            this.controls.maxPolarAngle = Infinity;
        });
    }
    setDistance(val, lock) {
        this.controls.minDistance = this.controls.maxDistance = val * scaleDown;
        this.controls.update();
        if (lock) {
            this.controls.enableZoom = false;
            return;
        }
        queueMicrotask(() => {
            this.controls.minDistance = -Infinity;
            this.controls.maxDistance = Infinity;
        });
    }
}
applyMixins(OrbitCamera, [CameraMixin]);
export default OrbitCamera;
