import { applyMixins, forceGet, lazy } from "@lincode/utils";
import { ExtrudeBufferGeometry, Group, Mesh, MeshStandardMaterial } from "three";
import Loaded from "./core/Loaded";
import TexturedBasicMixin from "./core/mixins/TexturedBasicMixin";
import TexturedStandardMixin from "./core/mixins/TexturedStandardMixin";
import fit from "./utils/fit";
import measure from "./utils/measure";
const lazyLoadSVG = lazy(() => import("./utils/loaders/loadSVG"));
const svgGeometryCache = new WeakMap();
class SvgMesh extends Loaded {
    constructor() {
        super(...arguments);
        this.material = new MeshStandardMaterial();
    }
    dispose() {
        if (this.done)
            return this;
        super.dispose();
        this.material.dispose();
        return this;
    }
    load(url) {
        return lazyLoadSVG().then(loader => loader.default(url));
    }
    resolveLoaded(svgData) {
        const loadedObject3d = new Group();
        const geometries = forceGet(svgGeometryCache, svgData, () => {
            const shapes = [];
            for (const path of svgData.paths)
                for (const shape of path.toShapes(true))
                    shapes.push(shape);
            if (!shapes.length)
                return [];
            const testGroup = new Group();
            for (const shape of shapes)
                testGroup.add(new Mesh(new ExtrudeBufferGeometry(shape, {
                    depth: 0,
                    bevelEnabled: false
                })));
            const size = measure(testGroup);
            const result = [];
            for (const shape of shapes)
                result.push(new ExtrudeBufferGeometry(shape, {
                    depth: size.y,
                    bevelEnabled: false
                }));
            return result;
        });
        for (const geometry of geometries) {
            const mesh = new Mesh(geometry, this.material);
            // mesh.castShadow = true
            // mesh.receiveShadow = true
            loadedObject3d.add(mesh);
        }
        const size = fit(loadedObject3d, this._src);
        !this.widthSet && (this.object3d.scale.x = size.x);
        !this.heightSet && (this.object3d.scale.y = size.y);
        !this.depthSet && (this.object3d.scale.z = size.z);
        loadedObject3d.scale.y *= -1;
        this.loadedGroup.add(loadedObject3d);
        this.loadedResolvable.resolve(loadedObject3d);
    }
}
applyMixins(SvgMesh, [TexturedBasicMixin, TexturedStandardMixin]);
export default SvgMesh;
