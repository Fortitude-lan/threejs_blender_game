import { Color, MeshBasicMaterial, Vector2, VideoTexture } from "three";
import loadTexture from "../../utils/loaders/loadTexture";
import { objectURLMapperPtr } from "../../utils/loaders/setObjectURLMapper";
import { Cancellable } from "@lincode/promiselikes";
const mapNames = ["map", "alphaMap"];
export default class TexturedBasicMixin {
    get color() {
        return "#" + this.material.color.getHexString();
    }
    set color(val) {
        this.material.color = new Color(val);
    }
    get vertexColors() {
        return this.material.vertexColors;
    }
    set vertexColors(val) {
        this.material.vertexColors = val;
    }
    get fog() {
        return this.material.fog;
    }
    set fog(val) {
        this.material.fog = val;
    }
    get opacity() {
        var _a;
        return (_a = this._opacity) !== null && _a !== void 0 ? _a : (this._opacity = 1.0);
    }
    set opacity(val) {
        var _a;
        this._opacity = val;
        this.material.opacity = val;
        this.material.transparent = (_a = this.transparent) !== null && _a !== void 0 ? _a : val < 1;
        //@ts-ignore
        this.object3d.visible = !!val;
    }
    get texture() {
        return this._texture;
    }
    set texture(url) {
        var _a;
        this._texture = url;
        (_a = this.materialHandle) === null || _a === void 0 ? void 0 : _a.cancel();
        if (url) {
            if (Array.isArray(url)) {
                const materials = url.map(src => new MeshBasicMaterial({ map: loadTexture(src) }));
                //@ts-ignore
                this.object3d.material = materials;
                this.materialHandle = new Cancellable(() => {
                    //@ts-ignore
                    this.object3d.material = this.material;
                    for (const material of materials)
                        material.dispose();
                });
            }
            else if (objectURLMapperPtr[0](url).endsWith(".mp4")) {
                const video = document.createElement("video");
                video.src = url;
                video.loop = true;
                video.autoplay = true;
                video.muted = true;
                video.playsInline = true;
                video.play();
                const videoTexture = new VideoTexture(video);
                this.material.map = videoTexture;
                this.materialHandle = new Cancellable(() => {
                    videoTexture.dispose();
                    video.pause();
                });
            }
            else
                this.material.map = loadTexture(url);
        }
        else
            this.material.map = null;
        this.material.needsUpdate = true;
        this.applyTextureRepeat(this.material.map);
    }
    get alphaMap() {
        return this._alphaMap;
    }
    set alphaMap(val) {
        this._alphaMap = val;
        this.material.alphaMap = val ? loadTexture(val) : null;
        this.applyTextureRepeat(this.material.alphaMap);
    }
    applyTextureRepeat(map) {
        map && this._textureRepeat && (map.repeat = this._textureRepeat);
    }
    get textureRepeat() {
        return this._textureRepeat;
    }
    set textureRepeat(val) {
        typeof val === "number" && (val = new Vector2(val, val));
        this._textureRepeat = val;
        if (!val)
            return;
        for (const name of mapNames)
            this.applyTextureRepeat(this.material[name]);
    }
}
