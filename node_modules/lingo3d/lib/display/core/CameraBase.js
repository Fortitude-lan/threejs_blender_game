import { Euler, Group } from "three";
import { getCamera } from "../../states/useCamera";
import { container } from "../../engine/render/renderer";
import { isMobile } from "react-device-detect";
import ObjectManager from "./ObjectManager";
import { deg2Rad, rad2Deg } from "@lincode/math";
import CameraMixin from "./mixins/CameraMixin";
import { applyMixins } from "@lincode/utils";
import { scaleUp, scaleDown } from "../../engine/constants";
import { ray, vector3_, vector3 } from "../utils/reusables";
import store, { createEffect } from "@lincode/reactivity";
import pillShape from "../../physics/shapes/pillShape";
import { Cancellable } from "@lincode/promiselikes";
const euler = new Euler(0, 0, 0, "YXZ");
const PI_2 = Math.PI * 0.5;
class CameraBase extends ObjectManager {
    constructor(camera) {
        super(new Group());
        this._physicsShape = pillShape;
        this._minPolarAngle = 5 * deg2Rad;
        this._maxPolarAngle = 175 * deg2Rad;
        this.mouseControlMode = 0;
        this.camera = camera;
        this.object3d.add(camera);
        this.initCamera();
    }
    getRay() {
        return ray.set(this.camera.getWorldPosition(vector3_), this.camera.getWorldDirection(vector3));
    }
    append(object) {
        this.camera.add(object.outerObject3d);
    }
    get width() {
        return this.object3d.scale.x * scaleUp;
    }
    set width(val) {
        const num = val * scaleDown;
        this.object3d.scale.x = num;
        this.camera.scale.x = 1 / num;
    }
    get height() {
        return this.object3d.scale.y * scaleUp;
    }
    set height(val) {
        const num = val * scaleDown;
        this.object3d.scale.y = num;
        this.camera.scale.y = 1 / num;
    }
    get depth() {
        return this.object3d.scale.z * scaleUp;
    }
    set depth(val) {
        const num = val * scaleDown;
        this.object3d.scale.z = num;
        this.camera.scale.z = 1 / num;
    }
    lookAt(target) {
        super.lookAt(target);
        this.rotationY += 180;
    }
    get mouseControl() {
        return !!this.camera.userData.mouseControl;
    }
    set mouseControl(val) {
        val ? this.enableMouseControl() : this.disableMouseControl();
    }
    get minPolarAngle() {
        return this._minPolarAngle * rad2Deg;
    }
    set minPolarAngle(val) {
        this._minPolarAngle = val * deg2Rad;
    }
    get maxPolarAngle() {
        return this._maxPolarAngle * rad2Deg;
    }
    set maxPolarAngle(val) {
        this._maxPolarAngle = val * deg2Rad;
    }
    gyrate(movementX, movementY, inner) {
        const manager = inner ? this.object3d : this.outerObject3d;
        euler.setFromQuaternion(manager.quaternion);
        euler.y -= movementX * 0.002;
        euler.x -= movementY * 0.002;
        euler.x = Math.max(PI_2 - this._maxPolarAngle, Math.min(PI_2 - this._minPolarAngle, euler.x));
        manager.quaternion.setFromEuler(euler);
        !inner && this.physicsUpdateRotation();
    }
    disableMouseControl() {
        var _a;
        if (!this.camera.userData.mouseControl)
            return;
        this.camera.userData.mouseControl = false;
        (_a = this.mouseControlHandle) === null || _a === void 0 ? void 0 : _a.cancel();
    }
    enableMouseControl() {
        if (this.camera.userData.mouseControl)
            return;
        this.camera.userData.mouseControl = true;
        if (isMobile) {
            let xTouch = 0;
            let yTouch = 0;
            const onTouchStart = (e) => {
                e.preventDefault();
                xTouch = e.targetTouches[0].clientX;
                yTouch = e.targetTouches[0].clientY;
            };
            const onTouchMove = (e) => {
                const xTouchNew = e.targetTouches[0].clientX;
                const yTouchNew = e.targetTouches[0].clientY;
                const movementX = xTouchNew - xTouch;
                const movementY = yTouchNew - yTouch;
                xTouch = xTouchNew;
                yTouch = yTouchNew;
                if (this.mouseControlMode === 0) {
                    this.gyrate(movementX * 2, 0);
                    this.gyrate(0, movementY * 2, true);
                }
                else
                    this.gyrate(movementX * 2, movementY * 2);
            };
            container.addEventListener("touchstart", onTouchStart);
            container.addEventListener("touchmove", onTouchMove);
            this.watch(this.mouseControlHandle = new Cancellable(() => {
                container.removeEventListener("touchstart", onTouchStart);
                container.removeEventListener("touchmove", onTouchMove);
            }));
        }
        else {
            const [setLocked, getLocked] = store(false);
            const handle = this.mouseControlHandle = this.watch(new Cancellable());
            handle.watch(createEffect(() => {
                if (!getLocked())
                    return;
                const onMouseMove = ({ movementX, movementY }) => {
                    if (this.mouseControlMode === 0) {
                        this.gyrate(movementX, 0);
                        this.gyrate(0, movementY, true);
                    }
                    else
                        this.gyrate(movementX, movementY);
                };
                document.addEventListener("mousemove", onMouseMove);
                return () => {
                    document.removeEventListener("mousemove", onMouseMove);
                };
            }, [getLocked]));
            const onClick = () => getCamera() === this.camera && container.requestPointerLock();
            container.addEventListener("click", onClick);
            const onPointerLockChange = () => setLocked(document.pointerLockElement === container);
            document.addEventListener("pointerlockchange", onPointerLockChange);
            handle.then(() => {
                container.removeEventListener("click", onClick);
                document.removeEventListener("pointerlockchange", onPointerLockChange);
                document.exitPointerLock();
                setLocked(false);
            });
        }
    }
}
applyMixins(CameraBase, [CameraMixin]);
export default CameraBase;
