import AnimationItem from "./AnimationItem";
import { physicsSet } from "../../../physics/physicsLoop";
import cubeShape from "../../../physics/shapes/cubeShape";
import { defaultMaterial, slipperyMaterial, world } from "../../../physics/physicsWorld";
import { Body, Vec3 } from "cannon-es";
import { Point3d } from "@lincode/math";
import scene from "../../../engine/scene";
const physicsGroups = [1, 2, 4, 8, 16, 32];
const physicsGroupIndexes = [0, 1, 2, 3, 4, 5];
export default class PhysicsItem extends AnimationItem {
    constructor() {
        super(...arguments);
        this._physicsShape = cubeShape;
    }
    dispose() {
        if (this.done)
            return this;
        super.dispose();
        if (this.physicsBody) {
            world.removeBody(this.physicsBody);
            physicsSet.delete(this);
        }
        return this;
    }
    getMAV() {
        var _a;
        return (_a = this._mAV) !== null && _a !== void 0 ? _a : (this._mAV = new Point3d(Infinity, Infinity, Infinity));
    }
    get maxAngularVelocityX() {
        var _a, _b;
        return (_b = (_a = this._mAV) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : Infinity;
    }
    set maxAngularVelocityX(val) {
        this.getMAV().x = val;
    }
    get maxAngularVelocityY() {
        var _a, _b;
        return (_b = (_a = this._mAV) === null || _a === void 0 ? void 0 : _a.y) !== null && _b !== void 0 ? _b : Infinity;
    }
    set maxAngularVelocityY(val) {
        this.getMAV().y = val;
    }
    get maxAngularVelocityZ() {
        var _a, _b;
        return (_b = (_a = this._mAV) === null || _a === void 0 ? void 0 : _a.z) !== null && _b !== void 0 ? _b : Infinity;
    }
    set maxAngularVelocityZ(val) {
        this.getMAV().z = val;
    }
    getMV() {
        var _a;
        return (_a = this._mV) !== null && _a !== void 0 ? _a : (this._mV = new Point3d(Infinity, Infinity, Infinity));
    }
    get maxVelocityX() {
        var _a, _b;
        return (_b = (_a = this._mV) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : Infinity;
    }
    set maxVelocityX(val) {
        this.getMV().x = val;
    }
    get maxVelocityY() {
        var _a, _b;
        return (_b = (_a = this._mV) === null || _a === void 0 ? void 0 : _a.y) !== null && _b !== void 0 ? _b : Infinity;
    }
    set maxVelocityY(val) {
        this.getMV().y = val;
    }
    get maxVelocityZ() {
        var _a, _b;
        return (_b = (_a = this._mV) === null || _a === void 0 ? void 0 : _a.z) !== null && _b !== void 0 ? _b : Infinity;
    }
    set maxVelocityZ(val) {
        this.getMV().z = val;
    }
    physicsUpdateRotation() {
        var _a;
        var _b;
        if (!this.physicsUpdate)
            return;
        const rotation = (_a = (_b = this.physicsUpdate).rotation) !== null && _a !== void 0 ? _a : (_b.rotation = {});
        rotation.x = true;
        rotation.y = true;
        rotation.z = true;
    }
    physicsUpdatePosition() {
        var _a;
        var _b;
        if (!this.physicsUpdate)
            return;
        const position = (_a = (_b = this.physicsUpdate).position) !== null && _a !== void 0 ? _a : (_b.position = {});
        position.x = true;
        position.y = true;
        position.z = true;
    }
    physicsUpdatePositionXZ() {
        var _a;
        var _b;
        if (!this.physicsUpdate)
            return;
        const position = (_a = (_b = this.physicsUpdate).position) !== null && _a !== void 0 ? _a : (_b.position = {});
        position.x = true;
        position.z = true;
    }
    applyForce(x, y, z) {
        queueMicrotask(() => { var _a; return (_a = this.physicsBody) === null || _a === void 0 ? void 0 : _a.applyForce(new Vec3(x, y, z)); });
    }
    applyImpulse(x, y, z) {
        queueMicrotask(() => { var _a; return (_a = this.physicsBody) === null || _a === void 0 ? void 0 : _a.applyImpulse(new Vec3(x, y, z)); });
    }
    applyLocalForce(x, y, z) {
        queueMicrotask(() => { var _a; return (_a = this.physicsBody) === null || _a === void 0 ? void 0 : _a.applyLocalForce(new Vec3(x, y, z)); });
    }
    applyLocalImpulse(x, y, z) {
        queueMicrotask(() => { var _a; return (_a = this.physicsBody) === null || _a === void 0 ? void 0 : _a.applyLocalImpulse(new Vec3(x, y, z)); });
    }
    applyTorque(x, y, z) {
        queueMicrotask(() => { var _a; return (_a = this.physicsBody) === null || _a === void 0 ? void 0 : _a.applyTorque(new Vec3(x, y, z)); });
    }
    setVelocity(x, y, z) {
        queueMicrotask(() => { var _a; return (_a = this.physicsBody) === null || _a === void 0 ? void 0 : _a.velocity.set(x, y, z); });
    }
    refreshPhysics() {
        if (this._physicsRunning) {
            this._disablePhysics();
            this._enablePhysics();
        }
    }
    get noTumble() {
        return this._noTumble;
    }
    set noTumble(val) {
        this._noTumble = val;
        this.refreshPhysics();
    }
    get slippery() {
        return this._slippery;
    }
    set slippery(val) {
        this._slippery = val;
        this.refreshPhysics();
    }
    get mass() {
        return this._mass;
    }
    set mass(val) {
        this._mass = val;
        this.refreshPhysics();
    }
    get physicsGroup() {
        return this._physicsGroup;
    }
    set physicsGroup(val) {
        this._physicsGroup = val;
        this.refreshPhysics();
    }
    get ignorePhysicsGroups() {
        return this._ignorePhysicsGroups;
    }
    set ignorePhysicsGroups(val) {
        this._ignorePhysicsGroups = val;
        this.refreshPhysics();
    }
    get physicsShape() {
        return this._physicsShape;
    }
    set physicsShape(val) {
        this._physicsShape = val;
        this.refreshPhysics();
    }
    _enablePhysics() {
        var _a, _b;
        if (this.done || !this._physics)
            return;
        this._physicsRunning = true;
        const body = this.physicsBody = new Body({
            mass: (_a = this._mass) !== null && _a !== void 0 ? _a : 1,
            material: this._slippery ? slipperyMaterial : defaultMaterial,
            collisionFilterGroup: physicsGroups[(_b = this._physicsGroup) !== null && _b !== void 0 ? _b : 0],
            collisionFilterMask: physicsGroupIndexes
                .filter(index => { var _a; return !((_a = this._ignorePhysicsGroups) === null || _a === void 0 ? void 0 : _a.includes(index)); })
                .map(index => physicsGroups[index])
                .reduce((acc, curr) => acc + curr, 0)
        });
        this._physicsShape(this);
        if (this._physics === "2d") {
            body.angularFactor = new Vec3(0, 0, 1);
            body.linearFactor = new Vec3(1, 1, 0);
        }
        if (this._noTumble)
            body.angularFactor = new Vec3(0, 0, 0);
        //@ts-ignore
        body.position.copy(this.outerObject3d.position);
        //@ts-ignore
        body.quaternion.copy(this.outerObject3d.quaternion);
        world.addBody(body);
        physicsSet.add(this);
    }
    enablePhysics(val) {
        if (this._physics)
            return;
        this._physics = val !== null && val !== void 0 ? val : true;
        queueMicrotask(() => this._enablePhysics());
        this.outerObject3d.parent !== scene && scene.attach(this.outerObject3d);
        this.physicsUpdate = {};
    }
    _disablePhysics() {
        if (!this.physicsBody)
            return;
        this._physicsRunning = false;
        world.removeBody(this.physicsBody);
        physicsSet.delete(this);
        this.physicsBody = undefined;
    }
    disablePhysics() {
        if (!this._physics)
            return;
        this._physics = false;
        queueMicrotask(() => this._disablePhysics());
    }
    get physics() {
        var _a;
        return (_a = this._physics) !== null && _a !== void 0 ? _a : false;
    }
    set physics(val) {
        if (!val) {
            this.disablePhysics();
            return;
        }
        this.enablePhysics(val === "2d" ? "2d" : undefined);
    }
}
