import { Raycaster } from "three";
import { mouseEvents } from "../../../api/mouse";
import { createEffect, createRef } from "@lincode/reactivity";
import { getSelection } from "../../../states/useSelection";
import { getSelectionTarget, setSelectionTarget } from "../../../states/useSelectionTarget";
import { getCamera } from "../../../states/useCamera";
import { getSelectionEnabled } from "../../../states/useSelectionEnabled";
import scene from "../../../engine/scene";
import { getMultipleSelection } from "../../../states/useMultipleSelection";
import { getMultipleSelectionTargets, pullMultipleSelectionTargets, pushMultipleSelectionTargets, resetMultipleSelectionTargets } from "../../../states/useMultipleSelectionTargets";
import { emitSelectionTarget, onSelectionTarget } from "../../../events/onSelectionTarget";
import Point3d from "../../../api/Point3d";
import { scaleUp } from "../../../engine/constants";
const raycaster = new Raycaster();
const getSelectionCandidates = () => {
    const result = new Set();
    scene.traverse(c => {
        const { manager } = c.userData;
        manager && result.add(manager.object3d);
    });
    return result;
};
const raycast = (x, y, objectSet) => {
    raycaster.setFromCamera({ x, y }, getCamera());
    return raycaster.intersectObjects([...objectSet])[0];
};
const pickable = (name, objectSet, then) => (mouseEvents.on(name, e => {
    const result = raycast(e.xNorm, e.yNorm, objectSet);
    if (!result)
        return;
    const { x, y, z } = result.point;
    const point = new Point3d(x * scaleUp, y * scaleUp, z * scaleUp);
    const distance = result.distance * scaleUp;
    then(result.object.userData.manager, { ...e, point, distance });
}));
export const clickSet = new Set();
export const mouseDownSet = new Set();
export const mouseUpSet = new Set();
export const mouseOverSet = new Set();
export const mouseOutSet = new Set();
export const mouseMoveSet = new Set();
createEffect(() => {
    const selection = getSelection();
    const selectionEnabled = getSelectionEnabled();
    const multipleSelection = getMultipleSelection();
    const firstMultipleSelection = createRef(true);
    createEffect(() => {
        !multipleSelection && (firstMultipleSelection.current = true);
    }, [multipleSelection]);
    if (selection) {
        if (selectionEnabled) {
            const handle0 = pickable("click", getSelectionCandidates(), target => {
                const parent = target === null || target === void 0 ? void 0 : target.outerObject3d.parent;
                const parentInstance = parent === null || parent === void 0 ? void 0 : parent.userData.manager;
                emitSelectionTarget(parentInstance !== null && parentInstance !== void 0 ? parentInstance : target);
            });
            const handle1 = onSelectionTarget(target => {
                if (multipleSelection) {
                    if (target) {
                        if (firstMultipleSelection.current) {
                            const currentTarget = getSelectionTarget();
                            currentTarget && pushMultipleSelectionTargets(currentTarget);
                        }
                        firstMultipleSelection.current = false;
                        if (getMultipleSelectionTargets().includes(target))
                            pullMultipleSelectionTargets(target);
                        else
                            pushMultipleSelectionTargets(target);
                    }
                }
                else {
                    resetMultipleSelectionTargets();
                    setSelectionTarget(target);
                }
            });
            return () => {
                handle0.cancel();
                handle1.cancel();
            };
        }
    }
    else {
        resetMultipleSelectionTargets();
        setSelectionTarget(undefined);
        const clickHandle = pickable("click", clickSet, (obj, e) => { var _a; return (_a = obj === null || obj === void 0 ? void 0 : obj.onClick) === null || _a === void 0 ? void 0 : _a.call(obj, e); });
        const downHandle = pickable("down", mouseDownSet, (obj, e) => { var _a; return (_a = obj === null || obj === void 0 ? void 0 : obj.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(obj, e); });
        const upHandle = pickable("up", mouseUpSet, (obj, e) => { var _a; return (_a = obj === null || obj === void 0 ? void 0 : obj.onMouseUp) === null || _a === void 0 ? void 0 : _a.call(obj, e); });
        let moveSet = new Set();
        let moveSetOld = new Set();
        const overHandle = pickable("move", mouseOverSet, (obj, e) => {
            if (!obj)
                return;
            moveSet.add(obj);
            obj.outerObject3d.userData.eMove = e;
        });
        const outHandle = pickable("move", mouseOutSet, (obj, e) => {
            if (!obj)
                return;
            moveSet.add(obj);
            obj.outerObject3d.userData.eMove = e;
        });
        const moveHandle = pickable("move", mouseMoveSet, (obj, e) => {
            if (!obj)
                return;
            moveSet.add(obj);
            obj.outerObject3d.userData.eMove = e;
        });
        const mouseMoveHandle = mouseEvents.on("move", () => {
            var _a, _b, _c;
            for (const obj of moveSet) {
                if (!moveSetOld.has(obj))
                    (_a = obj.onMouseOver) === null || _a === void 0 ? void 0 : _a.call(obj, obj.outerObject3d.userData.eMove);
                (_b = obj.onMouseMove) === null || _b === void 0 ? void 0 : _b.call(obj, obj.outerObject3d.userData.eMove);
            }
            for (const obj of moveSetOld)
                if (!moveSet.has(obj))
                    (_c = obj.onMouseOut) === null || _c === void 0 ? void 0 : _c.call(obj, obj.outerObject3d.userData.eMove);
            moveSetOld = moveSet;
            moveSet = new Set();
        });
        return () => {
            clickHandle.cancel();
            downHandle.cancel();
            upHandle.cancel();
            overHandle.cancel();
            outHandle.cancel();
            moveHandle.cancel();
            mouseMoveHandle.cancel();
        };
    }
}, [getSelection, getSelectionEnabled, getMultipleSelection]);
