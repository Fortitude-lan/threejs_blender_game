import Events from "@lincode/events";
import { container, containerBounds } from "../engine/render/renderer";
import { getSelection } from "../states/useSelection";
import { isMobile } from "react-device-detect";
import clientToWorld from "../display/utils/clientToWorld";
import { Group } from "three";
import EventLoopItem from "./core/EventLoopItem";
import { getCamera } from "../states/useCamera";
import { throttle } from "@lincode/utils";
export const mouseEvents = new Events();
let [clientXOld, clientYOld] = [0, 0];
const computeMouse = throttle((ev) => {
    var _a, _b;
    const pos = ev instanceof MouseEvent ? ev : ev.targetTouches[0];
    const rect = containerBounds[0];
    const clientX = ((_a = pos === null || pos === void 0 ? void 0 : pos.clientX) !== null && _a !== void 0 ? _a : clientXOld) - rect.x;
    const clientY = ((_b = pos === null || pos === void 0 ? void 0 : pos.clientY) !== null && _b !== void 0 ? _b : clientYOld) - rect.y;
    pos && ([clientXOld, clientYOld] = [pos.clientX, pos.clientY]);
    if (getCamera().userData.mouseControl)
        return { x: 0, y: 0, clientX, clientY, xNorm: 0, yNorm: 0 };
    const [x, y] = clientToWorld(clientX, clientY);
    const xNorm = (clientX / rect.width) * 2 - 1;
    const yNorm = -(clientY / rect.height) * 2 + 1;
    return { x, y, clientX, clientY, xNorm, yNorm };
}, 0, "leading");
const makeMouseEvent = (names) => (ev) => {
    const mouseData = computeMouse(ev);
    for (const name of names)
        mouseEvents.emit(name, mouseData);
};
if (isMobile) {
    document.addEventListener("touchmove", makeMouseEvent(["move"]));
    container.addEventListener("touchstart", makeMouseEvent(["click", "down", "move"]));
    container.addEventListener("touchend", makeMouseEvent(["up"]));
}
else {
    document.addEventListener("mousemove", makeMouseEvent(["move"]));
    container.addEventListener("click", makeMouseEvent(["click"]));
    container.addEventListener("mousedown", makeMouseEvent(["down"]));
    container.addEventListener("mouseup", makeMouseEvent(["up"]));
}
export class Mouse extends EventLoopItem {
    constructor() {
        super();
        this.outerObject3d = new Group();
        this.x = 0;
        this.y = 0;
        this.clientX = 0;
        this.clientY = 0;
        this.initOuterObject3d();
        let currentPayload = { x: 0, y: 0, clientX: 0, clientY: 0, xNorm: 0, yNorm: 0 };
        this.watch(mouseEvents.on("move", e => {
            var _a;
            this.x = e.x;
            this.y = e.y;
            this.clientX = e.clientX;
            this.clientY = e.clientY;
            !getSelection() && ((_a = this.onMouseMove) === null || _a === void 0 ? void 0 : _a.call(this, e));
            currentPayload = e;
        }));
        this.watch(mouseEvents.on("click", e => {
            var _a;
            !getSelection() && ((_a = this.onClick) === null || _a === void 0 ? void 0 : _a.call(this, e));
            currentPayload = e;
        }));
        let isDown = false;
        this.watch(mouseEvents.on("down", e => {
            var _a;
            !getSelection() && ((_a = this.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(this, e));
            isDown = true;
            currentPayload = e;
        }));
        this.watch(mouseEvents.on("up", e => {
            var _a;
            !getSelection() && ((_a = this.onMouseUp) === null || _a === void 0 ? void 0 : _a.call(this, e));
            isDown = false;
            currentPayload = e;
        }));
        this.loop(() => { var _a; return isDown && !getSelection() && ((_a = this.onMousePress) === null || _a === void 0 ? void 0 : _a.call(this, currentPayload)); });
    }
}
export default new Mouse();
