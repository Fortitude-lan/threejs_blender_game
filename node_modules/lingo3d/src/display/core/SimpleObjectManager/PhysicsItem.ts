import AnimationItem from "./AnimationItem"
import { physicsSet } from "../../../physics/physicsLoop"
import cubeShape from "../../../physics/shapes/cubeShape"
import { defaultMaterial, slipperyMaterial, world } from "../../../physics/physicsWorld"
import { Body, Vec3 } from "cannon-es"
import { Point3d } from "@lincode/math"
import scene from "../../../engine/scene"
import { Object3D } from "three"
import IPhysics, { PhysicsGroupIndex, PhysicsOptions, PhysicsShape } from "../../../interface/IPhysics"

const physicsGroups = <const>[1, 2, 4, 8, 16, 32]
const physicsGroupIndexes = <const>[0, 1, 2, 3, 4, 5]

export default abstract class PhysicsItem extends AnimationItem implements IPhysics {
    public abstract object3d: Object3D

    public override dispose() {
        if (this.done) return this
        super.dispose()

        if (this.physicsBody) {
            world.removeBody(this.physicsBody)
            physicsSet.delete(this)
        }
        return this
    }

    public _mAV?: Point3d
    private getMAV() {
        return this._mAV ??= new Point3d(Infinity, Infinity, Infinity)
    }
    public get maxAngularVelocityX() {
        return this._mAV?.x ?? Infinity
    }
    public set maxAngularVelocityX(val: number) {
        this.getMAV().x = val
    }
    public get maxAngularVelocityY() {
        return this._mAV?.y ?? Infinity
    }
    public set maxAngularVelocityY(val: number) {
        this.getMAV().y = val
    }
    public get maxAngularVelocityZ() {
        return this._mAV?.z ?? Infinity
    }
    public set maxAngularVelocityZ(val: number) {
        this.getMAV().z = val
    }

    public _mV?: Point3d
    private getMV() {
        return this._mV ??= new Point3d(Infinity, Infinity, Infinity)
    }
    public get maxVelocityX() {
        return this._mV?.x ?? Infinity
    }
    public set maxVelocityX(val: number) {
        this.getMV().x = val
    }
    public get maxVelocityY() {
        return this._mV?.y ?? Infinity
    }
    public set maxVelocityY(val: number) {
        this.getMV().y = val
    }
    public get maxVelocityZ() {
        return this._mV?.z ?? Infinity
    }
    public set maxVelocityZ(val: number) {
        this.getMV().z = val
    }
    
    protected physicsUpdate?: {
        position?: { x?: boolean, y?: boolean, z?: boolean }
        rotation?: { x?: boolean, y?: boolean, z?: boolean }
    }
    protected physicsUpdateRotation() {
        if (!this.physicsUpdate) return
        const rotation = this.physicsUpdate.rotation ??= {}
        rotation.x = true
        rotation.y = true
        rotation.z = true
    }
    protected physicsUpdatePosition() {
        if (!this.physicsUpdate) return
        const position = this.physicsUpdate.position ??= {}
        position.x = true
        position.y = true
        position.z = true
    }
    protected physicsUpdatePositionXZ() {
        if (!this.physicsUpdate) return
        const position = this.physicsUpdate.position ??= {}
        position.x = true
        position.z = true
    }
    
    public physicsBody?: Body

    public applyForce(x: number, y: number, z: number) {
        queueMicrotask(() => this.physicsBody?.applyForce(new Vec3(x, y, z)))
    }

    public applyImpulse(x: number, y: number, z: number) {
        queueMicrotask(() => this.physicsBody?.applyImpulse(new Vec3(x, y, z)))
    }

    public applyLocalForce(x: number, y: number, z: number) {
        queueMicrotask(() => this.physicsBody?.applyLocalForce(new Vec3(x, y, z)))
    }

    public applyLocalImpulse(x: number, y: number, z: number) {
        queueMicrotask(() => this.physicsBody?.applyLocalImpulse(new Vec3(x, y, z)))
    }

    public applyTorque(x: number, y: number, z: number) {
        queueMicrotask(() => this.physicsBody?.applyTorque(new Vec3(x, y, z)))
    }

    public setVelocity(x: number, y: number, z: number) {
        queueMicrotask(() => this.physicsBody?.velocity.set(x, y, z))
    }

    private refreshPhysics() {
        if (this._physicsRunning) {
            this._disablePhysics()
            this._enablePhysics()
        }
    }

    private _noTumble?: boolean
    public get noTumble() {
        return this._noTumble
    }
    public set noTumble(val: boolean | undefined) {
        this._noTumble = val
        this.refreshPhysics()
    }

    private _slippery?: boolean
    public get slippery() {
        return this._slippery
    }
    public set slippery(val: boolean | undefined) {
        this._slippery = val
        this.refreshPhysics()
    }

    private _mass?: number
    public get mass() {
        return this._mass
    }
    public set mass(val: number | undefined) {
        this._mass = val
        this.refreshPhysics()
    }

    private _physicsGroup?: PhysicsGroupIndex
    public get physicsGroup() {
        return this._physicsGroup
    }
    public set physicsGroup(val: PhysicsGroupIndex | undefined) {
        this._physicsGroup = val
        this.refreshPhysics()
    }

    private _ignorePhysicsGroups?: Array<PhysicsGroupIndex>
    public get ignorePhysicsGroups() {
        return this._ignorePhysicsGroups
    }
    public set ignorePhysicsGroups(val: Array<PhysicsGroupIndex> | undefined) {
        this._ignorePhysicsGroups = val
        this.refreshPhysics()
    }

    protected _physicsShape: PhysicsShape = cubeShape
    public get physicsShape() {
        return this._physicsShape
    }
    public set physicsShape(val: PhysicsShape) {
        this._physicsShape = val
        this.refreshPhysics()
    }

    private _physics?: PhysicsOptions
    private _physicsRunning?: boolean
    
    private _enablePhysics() {
        if (this.done || !this._physics) return

        this._physicsRunning = true

        const body = this.physicsBody = new Body({
            mass: this._mass ?? 1,
            material: this._slippery ? slipperyMaterial : defaultMaterial,
            collisionFilterGroup: physicsGroups[this._physicsGroup ?? 0],
            collisionFilterMask:
                physicsGroupIndexes
                    .filter(index => !this._ignorePhysicsGroups?.includes(index))
                    .map(index => physicsGroups[index])
                    .reduce((acc, curr) => acc + curr, 0)
        })
        this._physicsShape(this)

        if (this._physics === "2d") {
            body.angularFactor = new Vec3(0, 0, 1)
            body.linearFactor = new Vec3(1, 1, 0)
        }
        if (this._noTumble)
            body.angularFactor = new Vec3(0, 0, 0)

        //@ts-ignore
        body.position.copy(this.outerObject3d.position)
        //@ts-ignore
        body.quaternion.copy(this.outerObject3d.quaternion)

        world.addBody(body)
        physicsSet.add(this)
    }

    public enablePhysics(val?: "2d") {
        if (this._physics) return
        this._physics = val ?? true
        queueMicrotask(() => this._enablePhysics())
        this.outerObject3d.parent !== scene && scene.attach(this.outerObject3d)
        this.physicsUpdate = {}
    }

    private _disablePhysics() {
        if (!this.physicsBody) return

        this._physicsRunning = false

        world.removeBody(this.physicsBody)
        physicsSet.delete(this)
        this.physicsBody = undefined
    }

    public disablePhysics() {
        if (!this._physics) return
        this._physics = false
        queueMicrotask(() => this._disablePhysics())
    }

    public get physics() {
        return this._physics ?? false
    }
    public set physics(val: PhysicsOptions) {
        if (!val) {
            this.disablePhysics()
            return
        }
        this.enablePhysics(val === "2d" ? "2d" : undefined)
    }
}